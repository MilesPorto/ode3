///
/// @file 
/// @brief Test of Runge-Kutta solver for series of ODEs
/// @author Bob Hirosky
/// @date 31 Dec 2019 
/// 
/// Use the Rk4 solver for coupled ODEs to solve for projectile 
/// motion with air resistance
///
/// Definition of our variables
/// x    = time <br>
/// y[0] = position along i axis  ; f_ri = dri/dt => velocity along i axis  <br>
/// y[1] = velocity along i axis  ; f_vi = dvi/dt => acceleration along i axis <br>
/// y[2] = position along j axis  ; f_rj = drj/dt => velocity along j axis <br>
/// y[3] = velocity along j axis  ; f_vj = dvj/dt => acceleration along j axis <br>


#include "RKn.hpp"
#include "TROOT.h"
#include "TApplication.h"
#include "TLegend.h"
#include "TFile.h"
#include "TStyle.h"
#include "TGClient.h"
#include "TF1.h"
#include "TCanvas.h"
#include <iostream>
#include <cstdio>
#include <cstdlib>

using namespace std;


struct Params {
  double g;   ///< acceleration [m/s^2]
  double m;   ///< mass of object [kg], nb proj. In vacuum funcs do not depend on the mass
  double air_k;  ///< constant for air resistance. mass DOES matter with air resistance
} ;

// functions to describe simple projectile motion
// here use use ri,rj,rk to define directions to prevent confusion with
// standard ODE notation, where x=independent variable, \vec y=dependent variable(s)


/// \brief Change in position along \f$\hat i\f$ axis
/// \param[in] x independent variable
/// \param[in] y dependent variables
double f_ri(double x, const vector<double> &y, void *params=0){ 
  (void) x;   // prevent unused variable warning
  return y[1];
}

/// \brief Change in velocity along  \f$\hat i\f$ axis
/// \param[in] x independent variable
/// \param[in] y dependent variables
double f_vi(double x, const vector<double> &y, void *params=0){ 
  (void) x;
  Params *p = (Params*)params;
  return -p->air_k * sqrt(y[1]*y[1] + y[3]*y[3]) * y[1] / p->m;
  // return 0;  // if no air, no forces/acceleration along i direction in this problem
}

/// \brief Change in position along \f$\hat j\f$ axis
/// \param[in] x independent variable
/// \param[in] y dependent variables
///
/// Air resistance model: F= \f$k v^2\f$
///
double f_rj(double x, const vector<double> &y, void *params=0){  
  (void) x;   // prevent unused variable warning
  return y[3];
}

/// Change in velocity along  \f$\hat j\f$ axis
/// \param[in] x independent variable
/// \param[in] y dependent variables
double f_vj(double x, const vector<double> &y, void *params=0){  
  (void) x;
  Params *p = (Params*)params;
  return -p->air_k * sqrt(y[1]*y[1] + y[3]*y[3]) * y[3] / p->m - p->g;
  // return -g;    // if no air constant acceleration along -j direction: F/m = -g
}

/// \brief Stopping condition
/// \param[in] x independent variable
/// \param[in] y dependent variables
///
/// Returns 0(1) to flag continuation(termination) of calculation 
double f_stop(double x, const vector<double> &y, void *params=0){
  (void) x;
  Params *p = (Params*)params;
  
  // Stop when vertical velocity is downward and acceleration is near zero
  double aj = -p->air_k * sqrt(y[1]*y[1] + y[3]*y[3]) * y[3] / p->m - p->g;
  
  if (y[3] < 0 && fabs(aj) < 0.0001) return 1;  // falling AND near-zero acceleration
  
  return 0;
}
/// \brief Use RK4 method to describe simple projectile motion.
int main(int argc, char **argv){

  // setup default parameters
  Params pars;
  pars.g=9.81;
  pars.m=10.0;
  pars.air_k=0.1;
  std::vector<double> mlist;
  void *p_par = (void*) &pars;
  for (double x = 0.001; x < 0.01 - 1e-12; x += 0.001) mlist.push_back(x);
  for (double x = 0.01;  x < 0.1  - 1e-12; x += 0.01)  mlist.push_back(x);
  for (double x = 0.1;   x <= 10  + 1e-12; x += 0.1)   mlist.push_back(x);
  //cout<<mlist[1]<<mlist[2]<<mlist[3]<<endl;

  TGraph *tgVterm = new TGraph();  // Use pointer instead
  int ipoint = 0;

  double theta=180;   // initial angle degrees
  double v0=1;     // m/s
  
  int c;
  while ((c = getopt (argc, argv, "v:t:m:k:")) != -1)
    switch (c) {
    case 'v':
      v0 = atof(optarg);
      break;
    case 't':
      theta = atof(optarg);
      break;
    case 'm':
      pars.m = atof(optarg);
      break;
    case 'k':
      pars.air_k = atof(optarg);
      break;
    case '?':
      fprintf (stderr, "Unknown option `%c'.\n", optopt);
    }
  
  TApplication theApp("App", &argc, argv); // init ROOT App for displays

  // ******************************************************************************
  // ** this block is useful for supporting both high and std resolution screens **
  UInt_t dw = 800;
  UInt_t dh = 600;
  // ******************************************************************************

  // *** test 2: Use RK4SolveN to calculate simple projectile motion
  vector<pfunc_t> v_fun(4);   // 4 element vector of function pointers
  v_fun[0]=f_ri;
  v_fun[1]=f_vi;
  v_fun[2]=f_rj;
  v_fun[3]=f_vj;
  
  for (int j=0; j<(int)mlist.size();j++) {

    // set parameter mass
    pars.m = mlist[j];

    // reset initial conditions each time
    vector<double> y(4);
    y[0] = 0;
    y[1] = v0*cos(theta * M_PI/180.0);
    y[2] = 0;
    y[3] = v0*sin(theta * M_PI/180.0);

    double t0 = 0;
    double tmax = 20;
    int nsteps = 1000;

    // run RK4 for this mass
    auto tgN = RK4SolveN(v_fun, y, nsteps, t0, tmax, p_par, f_stop);
    

    // extract final velocity from the LAST point in the RK4 output
    int N = tgN[1].GetN();
    //cout<<N<<endl;
    /*
    if (mlist[j]==0.01){
      cout<<N<<endl;
      double t_test, vi_test,vj_test;
      for (int i=0;i<N;i++){
        tgN[1].GetPoint(i, t_test, vi_test);
        tgN[3].GetPoint(i, t_test, vj_test);
	cout<<"N: "<<i<<" vi: "<<vi_test<<" vj: "<<vj_test<<endl;
      }
    }*/
    
    
    double t_last, vi_last, vj_last;

    tgN[1].GetPoint(N-1, t_last, vi_last);
    tgN[3].GetPoint(N-1, t_last, vj_last);
    //cout<<vi_last<<vj_last<<endl;
    if (std::isnan(vi_last) || std::isnan(vj_last)){
      double t_test, vi_test,vj_test;
      for (int i=0;i<N;i++){
        tgN[1].GetPoint(i, t_test, vi_test);
        tgN[3].GetPoint(i, t_test, vj_test);
	cout<<"N: "<<i<<" vi: "<<vi_test<<" vj: "<<vj_test<<endl;
      }
      vi_last=vi_test;
      vj_last=vj_test;
    }
    cout<<"y velocity squared: "<<vj_last*vj_last<<endl;
    cout<<"x velocity squared: "<<vi_last*vi_last<<endl;

    // terminal velocity magnitude
    double vterm = sqrt(vi_last*vi_last + vj_last*vj_last);
    cout<<vterm<<endl;

    // store in the output graph
    if (!std::isnan(vterm)){
      tgVterm->SetPoint(ipoint++, mlist[j], vterm);}
  }
  cout << "Number of points in graph: " << tgVterm->GetN() << endl;

  // Debug: print first few points
  for (int i = 0; i < min(5, tgVterm->GetN()); i++) {
    double m, v;
    tgVterm->GetPoint(i, m, v);
    cout << "Point " << i << ": mass=" << m << ", vterm=" << v << endl;
  }
  

  //tgVterm.SetPoint(0,0.1,5);

  /*
  TGraph tgE;   // energy vs time
  int N = tgN[0].GetN();

  for (int i = 0; i < N; ++i) {
    double t, ri, rj, vi, vj;

    tgN[0].GetPoint(i, t, ri);
    tgN[1].GetPoint(i, t, vi);
    tgN[2].GetPoint(i, t, rj);
    tgN[3].GetPoint(i, t, vj);

    double E = pars.m * pars.g * rj
             + 0.5 * pars.m * (vi*vi + vj*vj);

    tgE.SetPoint(i, t, E);
  }
  */

  
  TCanvas *c2 = new TCanvas("c2","vterm vs mass",dw,dh);
  tgVterm->Draw("al*");
  c2->Draw();



  //cout << "Final velocity = " << sqrt(y[1]*y[1]+y[3]*y[3]) << endl;
  /*
  // save our graphs
  TFile *tf=new TFile("RKnDemo.root","recreate");
  for (unsigned i=0; i<v_fun.size(); i++){
    tgN[i].Write();
  }
  tgE.Write();
  tf->Close();
  */
  TFile* tf = new TFile("vterm.root","RECREATE");
  tgVterm->Write("vterm_vs_mass");
  tf->Close();

  
  cout << "Press ^c to exit" << endl;
  theApp.SetIdleTimer(30,".q");  // set up a failsafe timer to end the program  
  theApp.Run();
}

